<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bomber Kid - Complete Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            color: white;
            overflow: hidden;
            touch-action: none;
        }
        
        .game-container {
            width: 100%;
            max-width: 500px;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 25px;
            padding: 20px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
            text-align: center;
            position: relative;
        }
        
        h1 {
            color: #4dff4d;
            font-size: 2.2rem;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(77, 255, 77, 0.7);
        }
        
        .game-info {
            display: flex;
            justify-content: space-around;
            background: rgba(255, 204, 0, 0.2);
            padding: 12px;
            border-radius: 15px;
            margin: 15px 0;
            font-size: 1.1rem;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(11, 1fr);
            gap: 2px;
            background: #2c3e50;
            padding: 10px;
            border-radius: 15px;
            margin: 15px 0;
            aspect-ratio: 1/1;
        }
        
        .cell {
            background: #34495e;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            position: relative;
        }
        
        .wall { background: #7f8c8d; }
        .brick { background: #e74c3c; }
        .player { 
            background: radial-gradient(circle, #3498db, #2980b9);
            animation: pulse 2s infinite;
        }
        .bomb { 
            background: radial-gradient(circle, #f39c12, #e67e22);
            animation: bomb-pulse 1s infinite;
        }
        .explosion { 
            background: radial-gradient(circle, #e74c3c, #c0392b);
            animation: explosion 0.5s forwards;
        }
        .key { 
            background: radial-gradient(circle, #f1c40f, #f39c12);
            animation: key-pulse 2s infinite;
        }
        .door { 
            background: radial-gradient(circle, #9b59b6, #8e44ad);
            animation: door-pulse 2s infinite;
        }
        .door.unlocked {
            background: radial-gradient(circle, #2ecc71, #27ae60);
        }
        .powerup-fire {
            background: radial-gradient(circle, #e74c3c, #c0392b);
            animation: powerup-pulse 1.5s infinite;
        }
        .powerup-bomb {
            background: radial-gradient(circle, #3498db, #2980b9);
            animation: powerup-pulse 1.5s infinite;
        }
        .powerup-speed {
            background: radial-gradient(circle, #2ecc71, #27ae60);
            animation: powerup-pulse 1.5s infinite;
        }
        
        @keyframes powerup-pulse {
            0% { transform: scale(1) rotate(0deg); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            50% { transform: scale(1.15) rotate(180deg); box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { transform: scale(1) rotate(360deg); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .direction-btn {
            width: 60px;
            height: 60px;
            background: #4dff4d;
            border: none;
            border-radius: 50%;
            font-size: 1.8rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #000;
            font-weight: bold;
            transition: transform 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        .direction-btn:active {
            transform: scale(0.9);
        }
        
        .bomb-btn {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: none;
            border-radius: 50%;
            font-size: 2rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            transition: transform 0.2s;
            box-shadow: 0 6px 15px rgba(230, 126, 34, 0.5);
        }
        
        .bomb-btn:active {
            transform: scale(0.95);
        }
        
        .instructions {
            background: rgba(255, 204, 0, 0.15);
            padding: 15px;
            border-radius: 15px;
            margin: 15px 0;
            font-size: 0.95rem;
            line-height: 1.4;
        }
        
        .level-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(52, 152, 219, 0.8);
            padding: 5px 10px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(52, 152, 219, 0); }
            100% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0); }
        }
        
        @keyframes bomb-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        @keyframes explosion {
            0% { transform: scale(0.8); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        @keyframes key-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(241, 196, 15, 0.3); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(241, 196, 15, 0); }
        }
        
        @keyframes door-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 8px rgba(155, 89, 182, 0.3); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(155, 89, 182, 0); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üí£ Bomber Kid</h1>
        <div class="level-indicator">Level: <span id="level">1</span></div>
        
        <div class="game-info">
            <div>Has Key: <span id="has-key">No</span></div>
            <div>Bombs: <span id="bomb-count">1</span></div>
            <div>Fire: <span id="fire-range">2</span></div>
        </div>
        
        <div class="game-board" id="game-board"></div>
        
        <div class="instructions">
            <p><strong>How to Play:</strong> Use arrows to move. Drop bombs with üí£ button to destroy red bricks. Find the KEY üîë hidden in a brick! Then go to the DOOR üîí to unlock it and win! Watch out - bombs can kill you!</p>
            <p><strong>Power-ups:</strong> üî• Fire Range ‚Ä¢ üí£ Extra Bombs ‚Ä¢ ‚ö° Speed Boost</p>
        </div>
        
        <div class="controls">
            <button class="direction-btn" id="up-btn">‚Üë</button>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="direction-btn" id="left-btn">‚Üê</button>
                <button class="bomb-btn" id="bomb-btn">üí£</button>
                <button class="direction-btn" id="right-btn">‚Üí</button>
            </div>
            <button class="direction-btn" id="down-btn">‚Üì</button>
        </div>
    </div>

    <script>
        // Game constants
        const GRID_SIZE = 11;
        const CELL_TYPES = {
            EMPTY: 0,
            WALL: 1,
            BRICK: 2,
            PLAYER: 3,
            BOMB: 4,
            EXPLOSION: 5,
            KEY: 6,
            DOOR: 7,
            POWERUP_FIRE: 8,
            POWERUP_BOMB: 9,
            POWERUP_SPEED: 10
        };
        
        // Game state
        let grid = [];
        let playerPos = { x: 1, y: 1 };
        let hasKey = false;
        let bombCount = 1;
        let fireRange = 2;
        let moveSpeed = 200; // milliseconds between updates
        let activeBombs = [];
        let activeExplosions = [];
        let gameActive = true;
        let keyBrickPos = null;
        let keyRevealed = false;
        let doorPos = { x: 9, y: 9 };
        let currentLevel = 1;
        
        // DOM elements
        const gameBoard = document.getElementById('game-board');
        const hasKeyEl = document.getElementById('has-key');
        const bombCountEl = document.getElementById('bomb-count');
        const fireRangeEl = document.getElementById('fire-range');
        const levelEl = document.getElementById('level');
        const upBtn = document.getElementById('up-btn');
        const downBtn = document.getElementById('down-btn');
        const leftBtn = document.getElementById('left-btn');
        const rightBtn = document.getElementById('right-btn');
        const bombBtn = document.getElementById('bomb-btn');
        
        // Initialize game
        function initGame() {
            playerPos = { x: 1, y: 1 };
            hasKey = false;
            keyRevealed = false;
            bombCount = 1;
            fireRange = 2;
            moveSpeed = 200;
            activeBombs = [];
            activeExplosions = [];
            gameActive = true;
            keyBrickPos = null;
            
            hasKeyEl.textContent = 'No';
            bombCountEl.textContent = bombCount;
            fireRangeEl.textContent = fireRange;
            levelEl.textContent = currentLevel;
            
            grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(CELL_TYPES.EMPTY));
            
            // Create walls (outer borders)
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (y === 0 || y === GRID_SIZE - 1 || x === 0 || x === GRID_SIZE - 1) {
                        grid[y][x] = CELL_TYPES.WALL;
                    }
                }
            }
            
            // Create inner walls (grid pattern)
            for (let y = 2; y < GRID_SIZE - 2; y += 2) {
                for (let x = 2; x < GRID_SIZE - 2; x += 2) {
                    grid[y][x] = CELL_TYPES.WALL;
                }
            }
            
            // Create bricks (avoid player start area)
            const brickPositions = [];
            for (let y = 1; y < GRID_SIZE - 1; y++) {
                for (let x = 1; x < GRID_SIZE - 1; x++) {
                    if (grid[y][x] === CELL_TYPES.EMPTY && !(x <= 2 && y <= 2)) {
                        if (Math.random() > 0.5) {
                            grid[y][x] = CELL_TYPES.BRICK;
                            brickPositions.push({x, y});
                        }
                    }
                }
            }
            
            // Place key in random brick
            if (brickPositions.length > 0) {
                const randomIndex = Math.floor(Math.random() * brickPositions.length);
                keyBrickPos = brickPositions[randomIndex];
                // Remove key brick from available positions for powerups
                brickPositions.splice(randomIndex, 1);
            }
            
            // Reset powerup tracking
            brickPowerups = {};
            
            // Place powerups in random bricks (3-5 powerups per level)
            const powerupCount = Math.min(3 + Math.floor(currentLevel / 2), 5);
            const powerupTypes = [CELL_TYPES.POWERUP_FIRE, CELL_TYPES.POWERUP_BOMB, CELL_TYPES.POWERUP_SPEED];
            
            for (let i = 0; i < powerupCount && brickPositions.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * brickPositions.length);
                const pos = brickPositions[randomIndex];
                const powerupType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                
                // Store powerup location
                brickPowerups[`${pos.x},${pos.y}`] = powerupType;
                
                brickPositions.splice(randomIndex, 1);
            }
            
            // Place door in a safe position
            let doorPlaced = false;
            while (!doorPlaced) {
                doorPos = {
                    x: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2,
                    y: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2
                };
                
                if (grid[doorPos.y][doorPos.x] === CELL_TYPES.EMPTY) {
                    grid[doorPos.y][doorPos.x] = CELL_TYPES.DOOR;
                    doorPlaced = true;
                }
            }
            
            // Place player
            grid[playerPos.y][playerPos.x] = CELL_TYPES.PLAYER;
            
            renderGrid();
            
            // Start game loop
            if (window.gameLoop) clearInterval(window.gameLoop);
            window.gameLoop = setInterval(updateGame, moveSpeed);
        }
        
        // Render grid
        function renderGrid() {
            gameBoard.innerHTML = '';
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    // Check if there's a player on this cell
                    const hasPlayer = (playerPos.x === x && playerPos.y === y);
                    
                    switch (grid[y][x]) {
                        case CELL_TYPES.WALL:
                            cell.classList.add('wall');
                            cell.textContent = 'üß±';
                            break;
                        case CELL_TYPES.BRICK:
                            cell.classList.add('brick');
                            cell.textContent = 'üß±';
                            break;
                        case CELL_TYPES.PLAYER:
                            cell.classList.add('player');
                            cell.textContent = 'üë∂';
                            break;
                        case CELL_TYPES.BOMB:
                            cell.classList.add('bomb');
                            if (hasPlayer) {
                                cell.textContent = 'üë∂üí£';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = 'üí£';
                            }
                            break;
                        case CELL_TYPES.EXPLOSION:
                            cell.classList.add('explosion');
                            cell.textContent = 'üí•';
                            break;
                        case CELL_TYPES.KEY:
                            cell.classList.add('key');
                            if (hasPlayer) {
                                cell.textContent = 'üë∂üîë';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = 'üîë';
                            }
                            break;
                        case CELL_TYPES.DOOR:
                            cell.classList.add('door');
                            if (hasKey) {
                                cell.classList.add('unlocked');
                            }
                            if (hasPlayer) {
                                cell.textContent = hasKey ? 'üë∂üîì' : 'üë∂üîí';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = hasKey ? 'üîì' : 'üîí';
                            }
                            break;
                        case CELL_TYPES.POWERUP_FIRE:
                            cell.classList.add('powerup-fire');
                            if (hasPlayer) {
                                cell.textContent = 'üë∂üî•';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = 'üî•';
                            }
                            break;
                        case CELL_TYPES.POWERUP_BOMB:
                            cell.classList.add('powerup-bomb');
                            if (hasPlayer) {
                                cell.textContent = 'üë∂üí£';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = 'üí£';
                            }
                            break;
                        case CELL_TYPES.POWERUP_SPEED:
                            cell.classList.add('powerup-speed');
                            if (hasPlayer) {
                                cell.textContent = 'üë∂‚ö°';
                                cell.style.fontSize = '1.4rem';
                            } else {
                                cell.textContent = '‚ö°';
                            }
                            break;
                        default:
                            if (hasPlayer) {
                                cell.classList.add('player');
                                cell.textContent = 'üë∂';
                            }
                    }
                    
                    gameBoard.appendChild(cell);
                }
            }
        }
        
        // Move player
        function movePlayer(dx, dy) {
            if (!gameActive) return;
            
            const newX = playerPos.x + dx;
            const newY = playerPos.y + dy;
            
            // Check bounds
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                return;
            }
            
            const targetCell = grid[newY][newX];
            
            // Check if target is blocked (walls and bricks block movement)
            if (targetCell === CELL_TYPES.WALL || targetCell === CELL_TYPES.BRICK) {
                return;
            }
            
            // Move player
            playerPos.x = newX;
            playerPos.y = newY;
            
            // Check if picked up key
            if (targetCell === CELL_TYPES.KEY) {
                hasKey = true;
                hasKeyEl.textContent = 'Yes';
                grid[newY][newX] = CELL_TYPES.EMPTY;
            }
            
            // Check if picked up powerup
            if (targetCell === CELL_TYPES.POWERUP_FIRE) {
                fireRange++;
                fireRangeEl.textContent = fireRange;
                grid[newY][newX] = CELL_TYPES.EMPTY;
                showMessage('üî• Fire Range +1!');
            } else if (targetCell === CELL_TYPES.POWERUP_BOMB) {
                bombCount++;
                bombCountEl.textContent = bombCount;
                grid[newY][newX] = CELL_TYPES.EMPTY;
                showMessage('üí£ Max Bombs +1!');
            } else if (targetCell === CELL_TYPES.POWERUP_SPEED) {
                if (moveSpeed > 100) {
                    moveSpeed -= 30;
                    clearInterval(window.gameLoop);
                    window.gameLoop = setInterval(updateGame, moveSpeed);
                    showMessage('‚ö° Speed Boost!');
                }
                grid[newY][newX] = CELL_TYPES.EMPTY;
            }
            
            // Check win condition (player on door with key)
            if (targetCell === CELL_TYPES.DOOR && hasKey) {
                gameActive = false;
                setTimeout(() => {
                    currentLevel++;
                    alert(`üéâ Level ${currentLevel-1} Complete! Moving to Level ${currentLevel}!`);
                    initGame();
                }, 100);
            }
            
            renderGrid();
        }
        
        // Show temporary message
        function showMessage(text) {
            const messageEl = document.createElement('div');
            messageEl.textContent = text;
            messageEl.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 1.5rem;
                font-weight: bold;
                z-index: 1000;
                animation: fadeInOut 1.5s forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes fadeInOut {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(messageEl);
            
            setTimeout(() => {
                messageEl.remove();
                style.remove();
            }, 1500);
        }
        
        // Place bomb
        function placeBomb() {
            if (!gameActive) return;
            
            // Check if there's already a bomb at player position
            if (grid[playerPos.y][playerPos.x] === CELL_TYPES.BOMB) return;
            
            // Check bomb limit
            if (activeBombs.length >= bombCount) return;
            
            const bomb = {
                x: playerPos.x,
                y: playerPos.y,
                timer: 15 // 15 ticks = 3 seconds
            };
            
            activeBombs.push(bomb);
            grid[bomb.y][bomb.x] = CELL_TYPES.BOMB;
            renderGrid();
        }
        
        // Update game state
        function updateGame() {
            if (!gameActive) return;
            
            // Update bombs
            for (let i = activeBombs.length - 1; i >= 0; i--) {
                const bomb = activeBombs[i];
                bomb.timer--;
                
                if (bomb.timer <= 0) {
                    explodeBomb(bomb.x, bomb.y);
                    activeBombs.splice(i, 1);
                }
            }
            
            // Update explosions
            for (let i = activeExplosions.length - 1; i >= 0; i--) {
                const explosion = activeExplosions[i];
                explosion.timer--;
                
                if (explosion.timer <= 0) {
                    if (grid[explosion.y][explosion.x] === CELL_TYPES.EXPLOSION) {
                        grid[explosion.y][explosion.x] = CELL_TYPES.EMPTY;
                    }
                    activeExplosions.splice(i, 1);
                }
            }
            
            renderGrid();
        }
        
        // Explode bomb
        function explodeBomb(centerX, centerY) {
            const explosionCells = [{x: centerX, y: centerY}];
            
            // Clear the bomb from grid
            if (grid[centerY][centerX] === CELL_TYPES.BOMB) {
                grid[centerY][centerX] = CELL_TYPES.EMPTY;
            }
            
            // Directions: up, down, left, right
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            
            for (const [dx, dy] of directions) {
                for (let i = 1; i <= fireRange; i++) {
                    const x = centerX + dx * i;
                    const y = centerY + dy * i;
                    
                    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) break;
                    if (grid[y][x] === CELL_TYPES.WALL) break;
                    
                    // Check if this is the key brick
                    if (grid[y][x] === CELL_TYPES.BRICK) {
                        if (keyBrickPos && keyBrickPos.x === x && keyBrickPos.y === y && !keyRevealed) {
                            grid[y][x] = CELL_TYPES.KEY;
                            keyRevealed = true;
                        } else {
                            // Check if this brick has a powerup
                            const powerupKey = `${x},${y}`;
                            if (brickPowerups[powerupKey]) {
                                grid[y][x] = brickPowerups[powerupKey];
                                delete brickPowerups[powerupKey]; // Remove after revealing
                            } else {
                                grid[y][x] = CELL_TYPES.EMPTY;
                            }
                        }
                        break; // Bricks block explosions
                    }
                    
                    // Don't destroy the door
                    if (grid[y][x] === CELL_TYPES.DOOR) {
                        break;
                    }
                    
                    explosionCells.push({x, y});
                }
            }
            
            // Apply explosions
            for (const cell of explosionCells) {
                const cellType = grid[cell.y][cell.x];
                
                if (cellType !== CELL_TYPES.WALL && cellType !== CELL_TYPES.DOOR) {
                    // Check if player is in explosion
                    if (playerPos.x === cell.x && playerPos.y === cell.y) {
                        gameActive = false;
                        grid[cell.y][cell.x] = CELL_TYPES.EXPLOSION;
                        renderGrid();
                        setTimeout(() => {
                            alert('üíÄ Game Over! You were caught in the explosion!');
                            initGame();
                        }, 500);
                        return;
                    }
                    
                    if (cellType !== CELL_TYPES.KEY) {
                        grid[cell.y][cell.x] = CELL_TYPES.EXPLOSION;
                    }
                    activeExplosions.push({x: cell.x, y: cell.y, timer: 3});
                }
            }
        }
        
        // Event listeners
        upBtn.addEventListener('click', () => movePlayer(0, -1));
        downBtn.addEventListener('click', () => movePlayer(0, 1));
        leftBtn.addEventListener('click', () => movePlayer(-1, 0));
        rightBtn.addEventListener('click', () => movePlayer(1, 0));
        bombBtn.addEventListener('click', placeBomb);
        
        // Keyboard support
        document.addEventListener('keydown', (e) => {
            if (!gameActive) return;
            
            switch(e.key) {
                case 'ArrowUp': 
                case 'w':
                case 'W':
                    movePlayer(0, -1); 
                    e.preventDefault();
                    break;
                case 'ArrowDown': 
                case 's':
                case 'S':
                    movePlayer(0, 1); 
                    e.preventDefault();
                    break;
                case 'ArrowLeft': 
                case 'a':
                case 'A':
                    movePlayer(-1, 0); 
                    e.preventDefault();
                    break;
                case 'ArrowRight': 
                case 'd':
                case 'D':
                    movePlayer(1, 0); 
                    e.preventDefault();
                    break;
                case ' ':
                case 'Enter':
                    placeBomb(); 
                    e.preventDefault();
                    break;
            }
        });
        
        // Initialize game
        initGame();
    </script>
</body>
</html>